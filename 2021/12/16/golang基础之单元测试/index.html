<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      golang基础之单元测试 | Solost23&#39;s blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.1"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Solost23's blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>golang基础之单元测试</h2>
  <p class="post-date">2021-12-16</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>不写测试的开发不是好开发。</p>
<h3 id="go-test工具"><a href="#go-test工具" class="headerlink" title="go test工具"></a><center>go test工具</center></h3><p><code>golang</code>中测试依赖<code>go test</code>命令。编写测试代码和编写普通代码的过程类似，<code>go test</code>命令是一个按照一定约定和组织的测试代码的驱动程序。在包目录中，所有以<code>_test.go</code>为后缀名的源代码文件都是<code>go test</code>测试的一部分，不会被<code>go build</code>编译到最终的可执行文件中。</p>
<p>在<code>*_test.go</code>文件中有三种类型的函数，分别是单元测试函数、基准函数和示例函数。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">格式</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">测试函数</td>
<td align="center">函数名前缀为 Test</td>
<td align="center">测试程序的一些逻辑行为是否正确</td>
</tr>
<tr>
<td align="center">基准函数</td>
<td align="center">函数名前缀为 Benchmark</td>
<td align="center">测试函数的性能</td>
</tr>
<tr>
<td align="center">示例函数</td>
<td align="center">函数名前缀为 Example</td>
<td align="center">为文档提供示例文档</td>
</tr>
</tbody></table>
<p><code>go test</code>命令会遍历所有的<code>*_test.go</code>文件中符合上述命令规则的函数，然后生成一个临时的<code>main</code>包用于调试相应的测试函数，然后构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p>
<h3 id="测试函数"><a href="#测试函数" class="headerlink" title="测试函数"></a><center>测试函数</center></h3><p>每个测试函数必须导入<code>testing</code>包 eg:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestName</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试函数名字必须以<code>Test</code>开头，可选的后缀名必须以大写字母开头，eg:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSum</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLog</span><span class="params">(t *testing.T)</span></span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>t</code>用于报告测试失败和附加的日志信息，eg:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Parallel</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(t *T)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *T)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<h3 id="测试函数示例"><a href="#测试函数示例" class="headerlink" title="测试函数示例"></a><center>测试函数示例</center></h3><p>就像细胞是构成我们身体的基本单位，一个软件程序也是由很多单元组件构成的。单元组件可以是函数、结构体、方法和最终用户可能依赖的任何东西。总之我们需要确保这些组件是能够正常运行的。单元测试是一些利用各种方法测试单元组件的程序，它会将结果与预期输出进行比较。接下来，我们定义一个 split 的包，包中定义了一个 Split 函数，具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split.go</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strings&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// split package with a single split function.</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Split slices s into all substrings separated by sep and</span></span><br><span class="line"><span class="comment">// returns a slice of the substrings between those separators.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	index := strings.Index(s, sep)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> index &gt; <span class="number">-1</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, s[:index])</span><br><span class="line">		s = s[index+<span class="number">1</span>:]</span><br><span class="line">		index = strings.Index(s, sep)</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, s)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在当前目录下，我们创建一个 split_test.go 的测试文件，并定义一个测试函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split/split_test.go</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">package</span> split</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 测试函数名必须以Test开头，必须接收一个*testing.T类型参数</span></span><br><span class="line">	got := Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)         <span class="comment">// 程序输出的结果</span></span><br><span class="line">	want := []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;    <span class="comment">// 期望的结果</span></span><br><span class="line">	<span class="keyword">if</span> !reflect.DeepEqual(want, got) &#123; <span class="comment">// 因为slice不能直接比较，所以借助反射包中的方法比较</span></span><br><span class="line">		t.Errorf(<span class="string">&quot;excepted:%v, got:%v&quot;</span>, want, got) <span class="comment">// 测试失败输出错误提示</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 split 这个包中的文件如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split_string&gt;dir</span><br><span class="line"> 驱动器 C 中的卷没有标签。</span><br><span class="line"> 卷的序列号是 <span class="number">9058</span><span class="number">-02</span>B3</span><br><span class="line"> </span><br><span class="line"> C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split_string 的目录</span><br><span class="line"> </span><br><span class="line"><span class="number">2021</span>/<span class="number">03</span>/<span class="number">20</span>/周六  <span class="number">16</span>:<span class="number">03</span>    &lt;DIR&gt;          .</span><br><span class="line"><span class="number">2021</span>/<span class="number">03</span>/<span class="number">20</span>/周六  <span class="number">16</span>:<span class="number">03</span>    &lt;DIR&gt;          ..</span><br><span class="line"><span class="number">2021</span>/<span class="number">03</span>/<span class="number">20</span>/周六  <span class="number">16</span>:<span class="number">18</span>               <span class="number">512</span> split.<span class="keyword">go</span></span><br><span class="line"><span class="number">2021</span>/<span class="number">03</span>/<span class="number">20</span>/周六  <span class="number">16</span>:<span class="number">16</span>               <span class="number">247</span> split_test.<span class="keyword">go</span></span><br><span class="line">               <span class="number">2</span> 个文件            <span class="number">759</span> 字节</span><br><span class="line">               <span class="number">2</span> 个目录 <span class="number">175</span>,<span class="number">010</span>,<span class="number">402</span>,<span class="number">304</span> 可用字节</span><br></pre></td></tr></table></figure>

<p>在<code>split</code>包路径下，执行<code>go test</code>命令，可以得到如下结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">0.159</span>s</span><br></pre></td></tr></table></figure>

<h3 id="测试组"><a href="#测试组" class="headerlink" title="测试组"></a><center>测试组</center></h3><p>现在想要测试一下 Split 函数对中文字符串的支持，这个时候我们可以再编写一个 TestChineseSplit 测试函数，但是我们也可以使用如下更友好的一种方式来添加更多测试用例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 定义一个测试用例类型</span></span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">		input <span class="keyword">string</span></span><br><span class="line">		sep   <span class="keyword">string</span></span><br><span class="line">		want  []<span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义一个存储测试用例的切片</span></span><br><span class="line">	tests := []test&#123;</span><br><span class="line">		test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		test&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">		test&#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历切片，逐一执行测试用例</span></span><br><span class="line">	<span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		got := Split(tc.input, tc.sep)</span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;excepted:%v, got:%v&quot;</span>, tc.want, got)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过上面的代码把多个测试用例合到一起，再次执行 go test 命令：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">26</span>: excepted:[河有 又有河], got:[ 河有 又有河]</span><br><span class="line">--- FAIL: TestSplit (<span class="number">0.00</span>s)</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    calc/day09/split        <span class="number">0.032</span>s</span><br></pre></td></tr></table></figure>

<p>我们的测试出现了问题，仔细看打印的测试失败提示信息：excepted:[河有 又有河]，got:[河有 又有河]，你会发现 [河有 又有河] 中有个不明显的空串，这种情况下十分推荐使用 %#v 的格式化方式。</p>
<p>我们修改下测试用例的格式化输出错误提示部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">for</span> _, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		got := Split(tc.input, tc.sep)</span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;excepted:%#v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时运行 go test 命令后就能看到比较明显的提示信息了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">26</span>: excepted:[]<span class="keyword">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;, got:[]<span class="keyword">string</span>&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;</span><br><span class="line">--- FAIL: TestSplit (<span class="number">0.00</span>s)</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    calc/day09/split        <span class="number">0.162</span>s</span><br></pre></td></tr></table></figure>

<h3 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a><center>子测试</center></h3><p>看起来都挺不错的，但是如果测试用例比较多的时候，我们是没办法一眼看出来具体是哪个测试用例失败了。我们可能会想到下面的解决办法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">		input <span class="keyword">string</span></span><br><span class="line">		sep   <span class="keyword">string</span></span><br><span class="line">		want  []<span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">		<span class="string">&quot;simple&quot;</span>:      test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;wrong sep&quot;</span>:   test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;more sep&quot;</span>:    test&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;leading sep&quot;</span>: test&#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		got := Split(tc.input, tc.sep)</span><br><span class="line">		<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;name:%s excepted:%#v, got:%#v&quot;</span>, name, tc.want, got) <span class="comment">// 将测试用例的name格式化输出</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的做法是能够解决问题的。同时 Go1.7 + 中新增了子测试，我们可以按照如下方式使用 t.Run 执行子测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">		input <span class="keyword">string</span></span><br><span class="line">		sep   <span class="keyword">string</span></span><br><span class="line">		want  []<span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">		<span class="string">&quot;simple&quot;</span>:      test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;wrong sep&quot;</span>:   test&#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;more sep&quot;</span>:    test&#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;leading sep&quot;</span>: test&#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">			got := Split(tc.input, tc.sep)</span><br><span class="line">			<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;excepted:%#v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们再执行 go test 命令就能够看到更清晰的输出内容了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">=== RUN   TestSplit/leading_sep</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">24</span>: excepted:[]<span class="keyword">string</span>&#123;<span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;, got:[]<span class="keyword">string</span>&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;</span><br><span class="line">--- FAIL: TestSplit (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/simple (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/more_sep (<span class="number">0.00</span>s)</span><br><span class="line">    --- FAIL: TestSplit/leading_sep (<span class="number">0.00</span>s)</span><br><span class="line">FAIL</span><br><span class="line">exit status <span class="number">1</span></span><br><span class="line">FAIL    calc/day09/split        <span class="number">0.159</span>s</span><br></pre></td></tr></table></figure>

<p>这个时候我们要把测试用例中的错误修改回来：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">		<span class="string">&quot;simple&quot;</span>:      &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;wrong sep&quot;</span>:   &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;more sep&quot;</span>:    &#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;leading sep&quot;</span>: &#123;input: <span class="string">&quot;沙河有沙又有河&quot;</span>, sep: <span class="string">&quot;沙&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;河有&quot;</span>, <span class="string">&quot;又有河&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都知道可以通过 - run=RegExp 来指定运行的测试用例，还可以通过 / 来指定要运行的子测试用例，例如：go test -v -run=TestSplit/simple 只会运行 simple 对应的子测试用例。</p>
<h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a><center>测试覆盖率</center></h3><p>测试覆盖率是你的代码被测试套件覆盖的百分比。通常我们使用的都是语句的覆盖率，也就是在测试中至少被运行一次的代码占总代码的比例。</p>
<p>注意：一般的话测试函数覆盖率 100%，测试代码覆盖率 60%。</p>
<p>Go 提供内置功能来检查你的测试覆盖率。我们可以使用 go test -cover 来查看测试覆盖率。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -cover</span><br><span class="line">PASS</span><br><span class="line">coverage: <span class="number">100.0</span>% of statements        </span><br><span class="line">ok      calc/day09/split        <span class="number">0.161</span>s</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看到我们的测试用例覆盖了 100% 的代码。</p>
<p>Go 还提供了一个额外的 - coverprofile 参数，用来将覆盖率相关的记录输出到一个文件。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -cover -coverprofile=cover.out</span><br><span class="line">PASS</span><br><span class="line">coverage: <span class="number">100.0</span>% of statements        </span><br><span class="line">ok      calc/day09/split        <span class="number">0.035</span>s</span><br></pre></td></tr></table></figure>

<p>上面的命令会将覆盖率相关的信息输出到当前文件夹下面的 cover.out 文件中，然后我们执行 go tool cover -html=cover.out，使用 cover 工具来处理生成的记录信息，该命令会打开本地的浏览器窗口生成一个 HTML 报告。</p>
<p><img src="images/2021-03-20-175152.png"></p>
<p>上图中每个用绿色标记的语句块表示被覆盖了，而红色的表示没有被覆盖。</p>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a><center>基准测试</center></h3><p>基准测试就是在一定的工作负载之下检测程序性能的一种方法。基准测试的基本格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkName</span><span class="params">(b *testing.B)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基准测试以 Benchmark 为前缀，需要一个 * testing.B 类型的参数 b，基准测试必须要执行 b.N 次，这样的测试采用对照性，b.N 的值是系统根据实际情况去调整的，从而保证测试的稳定性。testing.B 拥有的方法如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Error</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Errorf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fail</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">FailNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Failed</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatal</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Fatalf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Log</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Logf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Name</span><span class="params">()</span> <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ReportAllocs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">ResetTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">Run</span><span class="params">(name <span class="keyword">string</span>, f <span class="keyword">func</span>(b *B)</span>) <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">RunParallel</span><span class="params">(body <span class="keyword">func</span>(*PB)</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetBytes</span><span class="params">(n <span class="keyword">int64</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">SetParallelism</span><span class="params">(p <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skip</span><span class="params">(args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">SkipNow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipf</span><span class="params">(format <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *B)</span> <span class="title">Skipped</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StartTimer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *B)</span> <span class="title">StopTimer</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h3 id="基准测试示例"><a href="#基准测试示例" class="headerlink" title="基准测试示例"></a><center>基准测试示例</center></h3><p>我们为 split 包中的 Split 函数编写基准测试如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基准测试并不会默认执行，需要增加 - bench 参数，所以我们通过执行 go test -bench=Split 命令执行基准测试，输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=Split</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64        </span><br><span class="line">pkg: calc/day09/split</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>         <span class="number">5699220</span>               <span class="number">202</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">1.528</span>s</span><br></pre></td></tr></table></figure>

<p>其中 BenchmarkSplit-8 表示对 Split 函数进行基准测试，数字 8 表示 GOMAXPROCS 的值，这个对于并发基准测试很重要，5699220 和 202 ns/op 表示每次调用 Split 函数耗时 202ns，这个结果是 5699220 次调用的平均值。</p>
<p>我们还可以为基准测试添加 - benchmem 参数，来获得内存分配的统计数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=Split -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: calc/day09/split</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>         <span class="number">5757889</span>               <span class="number">207</span> ns/op             <span class="number">112</span> B/op         <span class="number">3</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">1.436</span>s</span><br></pre></td></tr></table></figure>

<p>其中，112 B/op 表示每次操作内存分配了 112 字节，3 allocs/op 则表示每次操作进行了 3 次内存分配。我们将我们的 Split 函数优化如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Split</span><span class="params">(s, sep <span class="keyword">string</span>)</span> <span class="params">(result []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	result = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>, strings.Count(s, sep)+<span class="number">1</span>)</span><br><span class="line">	i := strings.Index(s, sep)</span><br><span class="line">	<span class="keyword">for</span> i &gt; <span class="number">-1</span> &#123;</span><br><span class="line">		result = <span class="built_in">append</span>(result, s[:i])</span><br><span class="line">		s = s[i+<span class="built_in">len</span>(sep):] <span class="comment">// 这里使用len(sep)获取sep的长度</span></span><br><span class="line">		i = strings.Index(s, sep)</span><br><span class="line">	&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, s)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一次我们提前使用 make 函数将 result 初始化为一个容量足够大的切片，而不再像之前一样通过调用 append 函数来追加，我们来看一下这个改进会带来多大的性能提升：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=Split -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64        </span><br><span class="line">pkg: calc/day09/split</span><br><span class="line">BenchmarkSplit<span class="number">-8</span>         <span class="number">9857104</span>               <span class="number">121</span> ns/op              <span class="number">48</span> B/op         <span class="number">1</span> allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">1.480</span>s</span><br></pre></td></tr></table></figure>

<p>这个使用 make 函数提前分配内存的改动，减少了 2/3 的内存分配次数，并且减少了一半的内存分配。</p>
<h3 id="性能比较函数"><a href="#性能比较函数" class="headerlink" title="性能比较函数"></a><center>性能比较函数</center></h3><p>上面的基准测试只能得到给定操作的绝对耗时，但是在很多性能问题是发生在两个不同操作之间的相对耗时，比如同一个函数处理 1000 个元素的耗时与处理 10000 个元素的耗时差别是多少？再或者对于同一个任务究竟使用哪种算法性能最佳？我们通常需要对两个不同算法的实现使用相同的输入来进行基准测试。</p>
<p>性能比较函数通常是一个带有参数的函数，被多个不同的 Benchmark 函数传入不同的值来调用。举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmark</span><span class="params">(b *testing.B, size <span class="keyword">int</span>)</span></span>&#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark10</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark100</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">100</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Benchmark1000</span><span class="params">(b *testing.B)</span></span>&#123; benchmark(b, <span class="number">1000</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>假如我们编写了一个计算斐波那契数列的函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib.go</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// Fib 是一个计算第n个斐波那契数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fib(n<span class="number">-1</span>) + Fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们编写的性能比较函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fib_test.go</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">benchmarkFib</span><span class="params">(b *testing.B, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Fib(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib1</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">1</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib2</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">2</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib3</span><span class="params">(b *testing.B)</span></span>  &#123; benchmarkFib(b, <span class="number">3</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib10</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">10</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib20</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">20</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFib40</span><span class="params">(b *testing.B)</span></span> &#123; benchmarkFib(b, <span class="number">40</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>运行基准测试：</p>
<p>-bench=.：所有基准测试都运行，. 可改为测试用例名字，例如：Fib20。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=. </span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: calc/day09/split</span><br><span class="line">BenchmarkFib1<span class="number">-8</span>         <span class="number">694827242</span>                <span class="number">1.69</span> ns/op</span><br><span class="line">BenchmarkFib2<span class="number">-8</span>         <span class="number">244322504</span>                <span class="number">4.93</span> ns/op</span><br><span class="line">BenchmarkFib3<span class="number">-8</span>         <span class="number">140462852</span>                <span class="number">8.69</span> ns/op</span><br><span class="line">BenchmarkFib10<span class="number">-8</span>         <span class="number">3747007</span>               <span class="number">314</span> ns/op</span><br><span class="line">BenchmarkFib20<span class="number">-8</span>           <span class="number">30793</span>             <span class="number">38917</span> ns/op</span><br><span class="line">BenchmarkFib40<span class="number">-8</span>               <span class="number">2</span>         <span class="number">603074600</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">10.243</span>s</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，默认情况下，每个基准测试至少运行 1 秒。如果在 Benchmark 函数返回时没有到 1 秒，则 b.N 的值会按 1，2，5，10，20，50，。。。增加，并且函数再次运行。</p>
<p>最终的 BenchmarkFib40 只运行了两次，每次运行的平均值只有不到 1 秒。像这种情况下我们应该可以使用 - benchtime 标志增加最小基准时间，以产生更准确的结果。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=Fib40 -benchtime=<span class="number">20</span>s</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64        </span><br><span class="line">pkg: calc/day09/split</span><br><span class="line">BenchmarkFib40<span class="number">-8</span>              <span class="number">40</span>         <span class="number">593312638</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">24.353</span>s</span><br></pre></td></tr></table></figure>

<p>这一次 BenchmarkFib40 函数运行了 40 次，结果就会更准确些了。</p>
<p>使用性能比较函数做测试的时候一个容易犯的错误就是把 b.N 作为输入的大小，例如以下两个例子都是错误的示范：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示范1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">		Fib(n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误示范2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkFibWrong2</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	Fib(b.N)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重置时间"><a href="#重置时间" class="headerlink" title="重置时间"></a><center>重置时间</center></h3><p>b.ResetTimer 之前的处理不会放到执行时间里，也不会输出到报告中，所以可以在之前做一些不计划作为测试报告的操作，比如连接数据库等。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplit</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second) <span class="comment">// 假设需要做一些耗时的无关操作</span></span><br><span class="line">	b.ResetTimer()              <span class="comment">// 重置计时器</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a><center>并行测试</center></h3><p>func (b *B) RunParallel (body func (*PB)) 会以并行的方式执行给定的基准测试。</p>
<p>RunParallel 会创建出多个 goroutine，并将 b.N 分配给这些 goroutine 执行，其中 goroutine 数量的默认值为 GOMAXPROCS。用户如果想要增加非 CPU 受限（non-CPU-bound）基准测试的并行性，那么可以在 RunParallel 之前调用 SetParallelism。RunParallel 通常会与 - cpu 标志一同使用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSplitParallel</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="comment">// b.SetParallelism(1) // 设置使用的CPU数</span></span><br><span class="line">	b.RunParallel(<span class="function"><span class="keyword">func</span><span class="params">(pb *testing.PB)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> pb.Next() &#123;</span><br><span class="line">			Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行以下基准测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -bench=.</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: calc/day09/split      </span><br><span class="line">BenchmarkSplitParallel<span class="number">-8</span>        <span class="number">55758820</span>                <span class="number">21.6</span> ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">2.321</span>s</span><br></pre></td></tr></table></figure>

<p>还可以通过在测试命令后添加 - cpu 参数和 go test -bench=. -cpu 1 来指定使用的 CPU 数量。</p>
<h3 id="Setup与TearDown"><a href="#Setup与TearDown" class="headerlink" title="Setup与TearDown"></a><center>Setup与TearDown</center></h3><p>测试程序有时需要在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）。</p>
<h4 id="TestMain"><a href="#TestMain" class="headerlink" title="TestMain"></a><font color=red>TestMain</font></h4><p>通过在 <code>*_test.go</code> 文件中定义 <code>TestMain</code> 函数来可以在测试之前进行额外的设置（setup）或在测试之后进行拆卸（teardown）操作。</p>
<p>如果测试文件包含函数:<code>func TestMain(m *testing.M)</code> 那么生成的测试会先调用 TestMain (m)，然后再运行具体测试。<code>TestMain</code> 运行在主 <code>goroutine</code> 中，可以在调用 <code>m.Run</code> 前后做任何设置（setup）和拆卸（teardown）。退出测试的时候应该使用 <code>m.Run</code> 的返回值作为参数调用 <code>os.Exit</code>。</p>
<p>一个使用 <code>TestMain</code> 来设置 Setup 和 TearDown 的示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMain</span><span class="params">(m *testing.M)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;write setup code here...&quot;</span>) <span class="comment">// 测试之前的做一些设置</span></span><br><span class="line">	<span class="comment">// 如果 TestMain 使用了 flags，这里应该加上flag.Parse()</span></span><br><span class="line">	retCode := m.Run()                         <span class="comment">// 执行测试</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;write teardown code here...&quot;</span>) <span class="comment">// 测试之后做一些拆卸工作</span></span><br><span class="line">	os.Exit(retCode)                           <span class="comment">// 退出测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：在调用 <code>TestMain</code> 时， <code>flag.Parse</code> 并没有被调用。所以如果 <code>TestMain</code> 依赖于 command-line 标志 (包括 testing 包的标记), 则应该显示的调用 <code>flag.Parse</code>。</p>
<h3 id="子测试的Setup与Teardown"><a href="#子测试的Setup与Teardown" class="headerlink" title="子测试的Setup与Teardown"></a><center>子测试的Setup与Teardown</center></h3><p>有时候我们可能需要为每个测试集设置 Setup 与 Teardown，也有可能需要为每个子测试设置 Setup 与 Teardown。下面我们定义两个函数工具函数如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试集的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupTestCase</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;如有需要在此执行:测试之前的setup&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		t.Log(<span class="string">&quot;如有需要在此执行:测试之后的teardown&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子测试的Setup与Teardown</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupSubTest</span><span class="params">(t *testing.T)</span> <span class="title">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	t.Log(<span class="string">&quot;如有需要在此执行:子测试之前的setup&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">		t.Log(<span class="string">&quot;如有需要在此执行:子测试之后的teardown&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSplit</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">type</span> test <span class="keyword">struct</span> &#123; <span class="comment">// 定义test结构体</span></span><br><span class="line">		input <span class="keyword">string</span></span><br><span class="line">		sep   <span class="keyword">string</span></span><br><span class="line">		want  []<span class="keyword">string</span></span><br><span class="line">	&#125;</span><br><span class="line">	tests := <span class="keyword">map</span>[<span class="keyword">string</span>]test&#123; <span class="comment">// 测试用例使用map存储</span></span><br><span class="line">		<span class="string">&quot;simple&quot;</span>:      &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;:&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;wrong sep&quot;</span>:   &#123;input: <span class="string">&quot;a:b:c&quot;</span>, sep: <span class="string">&quot;,&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a:b:c&quot;</span>&#125;&#125;,</span><br><span class="line">		<span class="string">&quot;more sep&quot;</span>:    &#123;input: <span class="string">&quot;abcd&quot;</span>, sep: <span class="string">&quot;bc&quot;</span>, want: []<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	teardownTestCase := setupTestCase(t) <span class="comment">// 测试之前执行setup操作</span></span><br><span class="line">	<span class="keyword">defer</span> teardownTestCase(t)            <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> name, tc := <span class="keyword">range</span> tests &#123;</span><br><span class="line">		t.Run(name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123; <span class="comment">// 使用t.Run()执行子测试</span></span><br><span class="line">			teardownSubTest := setupSubTest(t) <span class="comment">// 子测试之前执行setup操作</span></span><br><span class="line">			<span class="keyword">defer</span> teardownSubTest(t)           <span class="comment">// 测试之后执行testdoen操作</span></span><br><span class="line">			got := Split(tc.input, tc.sep)</span><br><span class="line">			<span class="keyword">if</span> !reflect.DeepEqual(got, tc.want) &#123;</span><br><span class="line">				t.Errorf(<span class="string">&quot;excepted:%#v, got:%#v&quot;</span>, tc.want, got)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -v</span><br><span class="line">=== RUN   TestSplit</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">52</span>: 如有需要在此执行:测试之前的setup     </span><br><span class="line">=== RUN   TestSplit/simple</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">60</span>: 如有需要在此执行:子测试之前的setup   </span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">62</span>: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">=== RUN   TestSplit/wrong_sep</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">60</span>: 如有需要在此执行:子测试之前的setup   </span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">62</span>: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">=== RUN   TestSplit/more_sep</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">60</span>: 如有需要在此执行:子测试之前的setup   </span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">62</span>: 如有需要在此执行:子测试之后的teardown</span><br><span class="line">=== CONT  TestSplit</span><br><span class="line">    split_test.<span class="keyword">go</span>:<span class="number">54</span>: 如有需要在此执行:测试之后的teardown  </span><br><span class="line">--- PASS: TestSplit (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/simple (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/wrong_sep (<span class="number">0.00</span>s)</span><br><span class="line">    --- PASS: TestSplit/more_sep (<span class="number">0.00</span>s)</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">0.163</span>s</span><br></pre></td></tr></table></figure>

<h3 id="示例函数"><a href="#示例函数" class="headerlink" title="示例函数"></a><center>示例函数</center></h3><p>被 go test 特殊对待的第三种函数就是示例函数，它们的函数名以 Example 为前缀。它们既没有参数也没有返回值。标准格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例函数示例"><a href="#示例函数示例" class="headerlink" title="示例函数示例"></a><center>示例函数示例</center></h3><p>下面的代码是我们为 Split 函数编写的一个示例函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleSplit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Split(<span class="string">&quot;a:b:c&quot;</span>, <span class="string">&quot;:&quot;</span>))</span><br><span class="line">	fmt.Println(Split(<span class="string">&quot;abcdef&quot;</span>, <span class="string">&quot;b&quot;</span>))</span><br><span class="line">	<span class="comment">// Output:</span></span><br><span class="line">	<span class="comment">// [a b c]</span></span><br><span class="line">	<span class="comment">// [a cdef]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为你的代码编写示例代码有如下三个用处：</p>
<ul>
<li>示例函数能够作为文档直接使用，例如基于 web 的 godoc 中能把示例函数与对应的函数或包相关联。</li>
<li>示例函数只要包含了 //Output：也是可以通过 go test 运行的可执行测试。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\ASUS\<span class="keyword">go</span>\src\calc\day09\split&gt;<span class="keyword">go</span> test -run Example</span><br><span class="line">PASS</span><br><span class="line">ok      calc/day09/split        <span class="number">0.157</span>s</span><br></pre></td></tr></table></figure>

<ul>
<li>示例函数提供了可以直接运行的示例代码，可以直接在 golang.org 的 godoc 文档服务器上使用 Goplaygroune 运行示例代码。下图为 strings.ToUpper 函数在 Playground 的示例</li>
</ul>
<p><img src="images/example.png"></p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#golang" >
    <span class="tag-code">golang</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/12/15/golang%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">
        <span class="nav-arrow">← </span>
        
          golang基础之网络编程
        
      </a>
    
    
      <a class="nav-right" href="/2021/12/20/golang%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Btime/">
        
          golang标准库之time
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo=""
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#go-test%E5%B7%A5%E5%85%B7"><span class="toc-nav-text">go test工具</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-nav-text">测试函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-nav-text">测试函数示例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%84"><span class="toc-nav-text">测试组</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AD%90%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">子测试</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87"><span class="toc-nav-text">测试覆盖率</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">基准测试</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-nav-text">基准测试示例</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0"><span class="toc-nav-text">性能比较函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E9%87%8D%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="toc-nav-text">重置时间</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%B9%B6%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="toc-nav-text">并行测试</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Setup%E4%B8%8ETearDown"><span class="toc-nav-text">Setup与TearDown</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#TestMain"><span class="toc-nav-text">TestMain</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E5%AD%90%E6%B5%8B%E8%AF%95%E7%9A%84Setup%E4%B8%8ETeardown"><span class="toc-nav-text">子测试的Setup与Teardown</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0"><span class="toc-nav-text">示例函数</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-nav-text">示例函数示例</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2021/12/16/golang基础之单元测试/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>